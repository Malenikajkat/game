# Проект Heroes: реализация алгоритмов для пошаговой стратегии

## Описание проекта

Проект реализует ключевые алгоритмы для игровой механики пошаговой стратегии с боевой системой. В рамках задания разработаны четыре основных модуля, отвечающих за:
- генерацию армии противника;
- симуляцию пошагового боя;
- отбор доступных целей для атаки;
- поиск кратчайшего пути между юнитами.

Проект организован как Gradle‑модуль `heroes_task`, подключающий библиотеку `heroes_task_lib`. Реализация выполнена в соответствии с интерфейсами библиотеки.

## Реализованные алгоритмы

### 1. Генерация армии противника (`GeneratePreset.generate`)

**Алгоритм:** жадный алгоритм с сортировкой по эффективности.

**Логика:**
1. Юниты из `unitList` сортируются по убыванию коэффициента `attack / cost` (приоритет — максимальная атака на единицу стоимости).
2. При равенстве коэффициентов — по убыванию `health / cost` (дополнительный критерий эффективности).
3. Юниты добавляются в армию до достижения лимита в 11 юнитов на тип и общей стоимости ≤ `maxPoints` (1500).

**Алгоритмическая сложность:**  
- Сортировка: $O(n \log n)$, где $n$ — число типов юнитов.
- Проход по отсортированному списку: $O(m)$, где $m$ — максимальное число юнитов в армии (в худшем случае — 11 × 4 = 44).
- **Итоговая сложность:** $O(n \log n + m) \approx O(n \log n)$, что лучше требуемой $O(n \cdot m)$.

**Обоснование:**  
Жадный подход гарантирует локально оптимальное решение на каждом шаге, что в совокупности даёт близкую к оптимальной армию по соотношению атака/стоимость.

---

### 2. Симуляция боя (`SimulateBattle.simulate`)

**Алгоритм:** пошаговая симуляция с сортировкой очереди ходов.

**Логика:**
1. В начале каждого раунда юниты обеих армий сортируются по убыванию `baseAttack`.
2. Юниты ходят по очереди в порядке сортировки.
3. После каждой атаки:
   - проверяется статус юнита‑цели (`isAlive`);
   - мёртвые юниты исключаются из очереди;
   - выводится лог через `printBattleLog`.
4. Бой завершается, когда в одной из армий не остаётся живых юнитов.

**Алгоритмическая сложность:**  
- Сортировка за раунд: $O(k \log k)$, где $k$ — общее число юнитов в обеих армиях.
- Число раундов: в худшем случае $O(k)$ (каждый юнит умирает за один ход).
- **Итоговая сложность:** $O(k^2 \log k)$, что соответствует требуемой $O(n^2 \log n)$ (где $n = k$).

**Обоснование:**  
Сортировка обеспечивает корректную очерёдность ходов. Исключение мёртвых юнитов предотвращает их участие в будущих раундах.

---

### 3. Отбор целей для атаки (`SuitableForAttackUnitsFinder.getSuitableUnits`)

**Алгоритм:** линейный проход по юнитам с проверкой видимости.

**Логика:**
1. Для каждой строки в `unitsByRow` (3 ряда) перебираются юниты.
2. Для армии компьютера (`isLeftArmyTarget = false`): юнит подходит, если справа (по `y + 1`) нет юнита его армии.
3. Для армии игрока (`isLeftArmyTarget = true`): юнит подходит, если слева (по `y - 1`) нет юнита его армии.
4. Подходящие юниты добавляются в результирующий список.

**Алгоритмическая сложность:**  
- Проход по всем юнитам: $O(p)$, где $p$ — общее число юнитов в `unitsByRow`.
- Проверка соседа: $O(1)$ на юнит.
- **Итоговая сложность:** $O(p)$, что лучше требуемой $O(n)$ (где $n$ — число юнитов в ряду).

**Обоснование:**  
Алгоритм однократно обходит все юниты, проверяя условие видимости. Сложность линейна относительно числа юнитов.

---

### 4. Поиск кратчайшего пути (`UnitTargetPathFinder.getTargetPath`)

**Алгоритм:** A* (A‑star) с эвристикой Манхэттена.

**Логика:**
1. Инициализируется открытая очередь (priority queue) с начальной клеткой (`attackUnit`).
2. Для каждой клетки проверяются 8 направлений (включая диагонали).
3. Препятствия (юниты из `existingUnitList`) игнорируются.
4. Эвристика: $h = |x_1 - x_2| + |y_1 - y_2|$ (Манхэттенское расстояние).
5. Путь восстанавливается через родительские ссылки.

**Алгоритмическая сложность:**  
- Число клеток: $W \times H = 27 \times 21 = 567$.
- Каждая клетка посещается один раз.
- Операция с очередью: $O(\log (W \cdot H))$.
- **Итоговая сложность:** $O(W \cdot H \cdot \log (W \cdot H))$, что соответствует требуемой.

**Обоснование:**  
A* оптимален для сеток с препятствиями. Эвристика сокращает число проверяемых узлов по сравнению с BFS или Дейкстрой.

## Сборка и запуск

1. **Сборка JAR:**  
   - Откройте проект в IntelliJ IDEA.
   - Перейдите в `File → Project Structure → Artifacts`.
   - Создайте JAR: `From modules with dependencies`.
   - Соберите: `Build → Build Artifacts`.

2. **Запуск игры:**  
   - Поместите собранный JAR в папку `heroes/jars`, заменив `obf.jar`.
   - Запустите игру:  
     ```bash
     java -jar "Heroes Battle-1.0.0.jar"
     ```

3. **Проверка алгоритмов:**  
   - «Сгенерировать пресет» — проверка `generate`.
   - «Начать бой» — проверка `simulate`, `getSuitableUnits`, `getTargetPath`.

## Тесты

В проекте включены юнит‑тесты для каждого метода:
- `GeneratePresetTest` — проверка корректности армии и сложности.
- `SimulateBattleTest` — проверка логики боя и очерёдности ходов.
- `SuitableForAttackUnitsFinderTest` — проверка отбора целей.
- `UnitTargetPathFinderTest` — проверка поиска пути и обработки препятствий.

## Автор

[malenikajkat]  
